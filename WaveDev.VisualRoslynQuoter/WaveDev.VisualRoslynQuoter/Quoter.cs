using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace WaveDev.VisualRoslynQuoter
{
    /// <summary>
    /// A tool that for a given C# program constructs Roslyn API calls to create a syntax tree that
    /// describes this program. As opposed to SyntaxTree.ParseText() that creates the syntax tree object
    /// graph in runtime, Quoter returns the C# source code that will construct such syntax tree object
    /// graph when compiled and executed.
    /// </summary>
    /// <example>
    /// new Quoter().Quote("class C{}") returns:
    /// 
    /// Syntax.CompilationUnit()
    /// .WithMembers(
    ///     Syntax.List&lt;MemberDeclarationSyntax&gt;
    ///         Syntax.ClassDeclaration(
    ///             Syntax.Identifier(
    ///                 @"C"))
    ///         .WithKeyword(
    ///             Syntax.Token(
    ///                 SyntaxKind.ClassKeyword,
    ///                 Syntax.TriviaList(
    ///                     Syntax.Space)))
    ///         .WithOpenBraceToken(
    ///             Syntax.Token(
    ///                 SyntaxKind.OpenBraceToken))
    ///         .WithCloseBraceToken(
    ///             Syntax.Token(
    ///                 SyntaxKind.CloseBraceToken))))
    /// .WithEndOfFileToken(
    ///     Syntax.Token(
    ///         SyntaxKind.EndOfFileToken))
    /// </example>
    public class Quoter
    {
        public bool OpenParenthesisOnNewLine { get; set; }
        public bool ClosingParenthesisOnNewLine { get; set; }
        public bool UseDefaultFormatting { get; set; }
        public bool RemoveRedundantModifyingCalls { get; set; }

        public Quoter()
        {
            UseDefaultFormatting = true;
            RemoveRedundantModifyingCalls = true;
        }

        /// <summary>
        /// Given the input C# program <paramref name="sourceText"/> returns the C# source code of
        /// Roslyn API calls that recreate the syntax tree for the input program.
        /// </summary>
        /// <param name="sourceText">A C# program (one compilation unit)</param>
        /// <returns>A C# expression that describes calls to the Roslyn syntax API necessary to recreate
        /// the syntax tree for the source program.</returns>
        public string Quote(string sourceText)
        {
            var sourceTree = CSharpSyntaxTree.ParseText(sourceText);
            return Quote(sourceTree.GetRoot());
        }

        /// <summary>
        /// Given the input C# syntax node <paramref name="node"/> returns the C# source code of
        /// Roslyn API calls that recreate the syntax node.
        /// </summary>
        /// <param name="sourceText">A C# syntax node</param>
        /// <returns>A C# expression that describes calls to the Roslyn syntax API necessary to recreate
        /// the input syntax node.</returns>
        public string Quote(SyntaxNode node)
        {
            ApiCall rootApiCall = Quote(node, name: null);
            if (UseDefaultFormatting)
            {
                rootApiCall.Add(new MethodCall { Name = ".NormalizeWhitespace" });
            }

            string generatedCode = Print(rootApiCall);
            return generatedCode;
        }

        /// <summary>
        /// Calls the Roslyn syntax API to actually create the syntax tree object and return the source
        /// code generated by the syntax tree.
        /// </summary>
        /// <param name="apiCallString">Code that calls Roslyn syntax APIs as a string</param>
        /// <returns>The string that corresponds to the code of the syntax tree.</returns>
        //public string Evaluate(string apiCallString, bool normalizeWhitespace = false)
        //{
        //    var generatedNode = evaluator.Evaluate(apiCallString) as SyntaxNode;
        //    if (normalizeWhitespace)
        //    {
        //        generatedNode = generatedNode.NormalizeWhitespace();
        //    }

        //    var resultText = generatedNode.ToFullString();
        //    return resultText;
        //}

        //private string Evaluate(ApiCall apiCall, bool normalizeWhitespace = false)
        //{
        //    return Evaluate(Print(apiCall), normalizeWhitespace);
        //}

        /// <summary>
        /// Recursive method that "quotes" a SyntaxNode, SyntaxToken, SyntaxTrivia or other objects.
        /// </summary>
        /// <returns>A description of Roslyn API calls necessary to recreate the input object.</returns>
        private ApiCall Quote(object treeElement, string name = null)
        {
            if (treeElement is SyntaxTrivia)
            {
                return QuoteTrivia((SyntaxTrivia)treeElement);
            }

            if (treeElement is SyntaxToken)
            {
                return QuoteToken((SyntaxToken)treeElement, name);
            }

            if (treeElement is SyntaxNodeOrToken)
            {
                SyntaxNodeOrToken syntaxNodeOrToken = (SyntaxNodeOrToken)treeElement;
                if (syntaxNodeOrToken.IsNode)
                {
                    return QuoteNode(syntaxNodeOrToken.AsNode(), name);
                }
                else
                {
                    return QuoteToken(syntaxNodeOrToken.AsToken(), name);
                }
            }

            return QuoteNode((SyntaxNode)treeElement, name);
        }

        /// <summary>
        /// The main recursive method that given a SyntaxNode recursively quotes the entire subtree.
        /// </summary>
        private ApiCall QuoteNode(SyntaxNode node, string name)
        {
            List<ApiCall> quotedPropertyValues = QuotePropertyValues(node);
            MethodInfo factoryMethod = PickFactoryMethodToCreateNode(node);

            var factoryMethodCall = new MethodCall()
            {
                Name = factoryMethod.DeclaringType.Name + "." + factoryMethod.Name
            };

            var codeBlock = new ApiCall(name, factoryMethodCall);

            AddFactoryMethodArguments(factoryMethod, factoryMethodCall, quotedPropertyValues);
            AddModifyingCalls(node, codeBlock, quotedPropertyValues);

            return codeBlock;
        }

        /// <summary>
        /// Inspects the property values of the <paramref name="node"/> object using Reflection and
        /// creates API call descriptions for the property values recursively. Properties that are not
        /// essential to the shape of the syntax tree (such as Span) are ignored.
        /// </summary>
        private List<ApiCall> QuotePropertyValues(SyntaxNode node)
        {
            var result = new List<ApiCall>();

            var properties = node.GetType().GetProperties(BindingFlags.Public | BindingFlags.Instance);

            // Filter out non-essential properties listed in nonStructuralProperties
            result.AddRange(properties
                .Where(propertyInfo => !nonStructuralProperties.Contains(propertyInfo.Name))
                .Select(propertyInfo => QuotePropertyValue(node, propertyInfo))
                .Where(apiCall => apiCall != null));

            // HACK: factory methods for the following node types accept back the first "kind" parameter
            // that we filter out above. Add an artificial "property value" that can be later used to
            // satisfy the first parameter of type SyntaxKind.
            if (node is AccessorDeclarationSyntax ||
                node is AssignmentExpressionSyntax ||
                node is BinaryExpressionSyntax ||
                node is ClassOrStructConstraintSyntax ||
                node is CheckedExpressionSyntax ||
                node is CheckedStatementSyntax ||
                node is ConstructorInitializerSyntax ||
                node is GotoStatementSyntax ||
                node is InitializerExpressionSyntax ||
                node is LiteralExpressionSyntax ||
                node is MemberAccessExpressionSyntax ||
                node is OrderingSyntax ||
                node is PostfixUnaryExpressionSyntax ||
                node is PrefixUnaryExpressionSyntax ||
                node is DocumentationCommentTriviaSyntax ||
                node is SwitchLabelSyntax ||
                node is YieldStatementSyntax)
            {
                result.Add(new ApiCall("Kind", "SyntaxKind." + node.Kind().ToString()));
            }

            return result;
        }

        /// <summary>
        /// Quote the value of the property <paramref name="property"/> of object <paramref
        /// name="node"/>
        /// </summary>
        private ApiCall QuotePropertyValue(SyntaxNode node, PropertyInfo property)
        {
            var value = property.GetValue(node, null);
            var propertyType = property.PropertyType;

            if (propertyType == typeof(SyntaxToken))
            {
                return QuoteToken((SyntaxToken)value, property.Name);
            }

            if (propertyType == typeof(SyntaxTokenList))
            {
                return QuoteList((IEnumerable)value, property.Name);
            }

            if (propertyType.IsGenericType &&
                (propertyType.GetGenericTypeDefinition() == typeof(SyntaxList<>) ||
                 propertyType.GetGenericTypeDefinition() == typeof(SeparatedSyntaxList<>)))
            {
                return QuoteList((IEnumerable)value, property.Name);
            }

            if (value is SyntaxNode)
            {
                return QuoteNode((SyntaxNode)value, property.Name);
            }

            if (value is string)
            {
                return new ApiCall(property.Name, "\"" + Escape(value.ToString()) + "\"");
            }

            if (value is bool)
            {
                return new ApiCall(property.Name, value.ToString().ToLowerInvariant());
            }

            return null;
        }

        private ApiCall QuoteList(IEnumerable syntaxList, string name)
        {
            IEnumerable<object> sourceList = syntaxList.Cast<object>();

            string methodName = "SyntaxFactory.List";
            string listType = null;
            var propertyType = syntaxList.GetType();
            if (propertyType.IsGenericType)
            {
                var methodType = propertyType.GetGenericArguments()[0].Name;
                listType = methodType;

                if (propertyType.GetGenericTypeDefinition() == typeof(SeparatedSyntaxList<>))
                {
                    listType = "SyntaxNodeOrToken";
                    methodName = "SyntaxFactory.SeparatedList";
                    sourceList = ((SyntaxNodeOrTokenList)
                        syntaxList.GetType().GetMethod("GetWithSeparators").Invoke(syntaxList, null))
                        .Cast<object>()
                        .ToArray();
                }

                methodName += "<" + methodType + ">";
            }

            if (propertyType.Name == "SyntaxTokenList")
            {
                methodName = "SyntaxFactory.TokenList";
            }

            if (propertyType.Name == "SyntaxTriviaList")
            {
                methodName = "SyntaxFactory.TriviaList";
            }

            var elements = new List<object>(sourceList
                .Select(o => Quote(o))
                .Where(cb => cb != null));
            if (elements.Count == 0)
            {
                return null;
            }
            else if (elements.Count == 1)
            {
                methodName = methodName.Replace(".List", ".SingletonList");
                methodName = methodName.Replace(".SeparatedList", ".SingletonSeparatedList");
            }
            else
            {
                elements = new List<object>
            {
                new ApiCall(
                    "methodName",
                    "new " + listType + "[]",
                    elements,
                    useCurliesInsteadOfParentheses: true)
            };
            }

            var codeBlock = new ApiCall(name, methodName, elements);
            return codeBlock;
        }

        private ApiCall QuoteToken(SyntaxToken value, string name)
        {
            if (value == default(SyntaxToken) || value.Kind() == SyntaxKind.None)
            {
                return null;
            }

            var arguments = new List<object>();
            string methodName = "SyntaxFactory.Token";
            string escapedTokenValueText = "@\"" + Escape(value.ToString()) + "\"";
            object leading = GetLeadingTrivia(value);
            object actualValue;
            object trailing = GetTrailingTrivia(value);

            if (leading != null || trailing != null)
            {
                leading = leading ?? GetEmptyTrivia("LeadingTrivia");
                trailing = trailing ?? GetEmptyTrivia("TrailingTrivia");
            }

            if (value.Kind() == SyntaxKind.IdentifierToken)
            {
                methodName = "SyntaxFactory.Identifier";
                if (value.IsMissing)
                {
                    methodName = "SyntaxFactory.MissingToken";
                }

                if (value.IsMissing)
                {
                    actualValue = value.Kind();
                }
                else
                {
                    actualValue = escapedTokenValueText;
                }

                AddIfNotNull(arguments, leading);
                arguments.Add(actualValue);
                AddIfNotNull(arguments, trailing);
            }
            else if (value.Kind() == SyntaxKind.XmlTextLiteralToken ||
                value.Kind() == SyntaxKind.XmlTextLiteralNewLineToken ||
                value.Kind() == SyntaxKind.XmlEntityLiteralToken)
            {
                methodName = "SyntaxFactory.XmlTextLiteral";
                if (value.Kind() == SyntaxKind.XmlTextLiteralNewLineToken)
                {
                    methodName = "SyntaxFactory.XmlTextNewLine";
                }
                else if (value.Kind() == SyntaxKind.XmlEntityLiteralToken)
                {
                    methodName = "SyntaxFactory.XmlEntity";
                }

                arguments.Add(leading ?? GetEmptyTrivia("LeadingTrivia"));
                arguments.Add(escapedTokenValueText);
                arguments.Add(escapedTokenValueText);
                arguments.Add(trailing ?? GetEmptyTrivia("TrailingTrivia"));
            }
            else if ((value.Parent is LiteralExpressionSyntax ||
                value.Kind() == SyntaxKind.StringLiteralToken ||
                value.Kind() == SyntaxKind.NumericLiteralToken) &&
                value.Kind() != SyntaxKind.TrueKeyword &&
                value.Kind() != SyntaxKind.FalseKeyword &&
                value.Kind() != SyntaxKind.NullKeyword &&
                value.Kind() != SyntaxKind.ArgListKeyword)
            {
                methodName = "SyntaxFactory.Literal";
                arguments.Add(leading ?? GetEmptyTrivia("LeadingTrivia"));
                arguments.Add(escapedTokenValueText);
                string escapedValue = value.ToString();
                if (value.Kind() == SyntaxKind.StringLiteralToken)
                {
                    escapedValue = escapedTokenValueText;
                }

                arguments.Add(escapedValue);
                arguments.Add(trailing ?? GetEmptyTrivia("TrailingTrivia"));
            }
            else
            {
                if (value.IsMissing)
                {
                    methodName = "SyntaxFactory.MissingToken";
                }

                if (value.Kind() == SyntaxKind.BadToken)
                {
                    methodName = "SyntaxFactory.BadToken";
                    leading = leading ?? GetEmptyTrivia("LeadingTrivia");
                    trailing = trailing ?? GetEmptyTrivia("TrailingTrivia");
                }

                object tokenValue = value.Kind();

                if (value.Kind() == SyntaxKind.BadToken)
                {
                    tokenValue = escapedTokenValueText;
                }

                AddIfNotNull(arguments, leading);
                arguments.Add(tokenValue);
                AddIfNotNull(arguments, trailing);
            }

            return new ApiCall(name, methodName, arguments);
        }

        private static void AddIfNotNull(List<object> arguments, object value)
        {
            if (value != null)
            {
                arguments.Add(value);
            }
        }

        private object GetLeadingTrivia(SyntaxToken value)
        {
            if (value.HasLeadingTrivia)
            {
                var quotedLeadingTrivia = QuoteList(value.LeadingTrivia, "LeadingTrivia");
                if (quotedLeadingTrivia != null)
                {
                    return quotedLeadingTrivia;
                }
            }

            return null;
        }

        private object GetTrailingTrivia(SyntaxToken value)
        {
            if (value.HasTrailingTrivia)
            {
                var quotedTrailingTrivia = QuoteList(value.TrailingTrivia, "TrailingTrivia");
                if (quotedTrailingTrivia != null)
                {
                    return quotedTrailingTrivia;
                }
            }

            return null;
        }

        private object GetEmptyTrivia(string parentPropertyName)
        {
            return new ApiCall(parentPropertyName, "SyntaxFactory.TriviaList", arguments: null);
        }

        private ApiCall QuoteTrivia(SyntaxTrivia syntaxTrivia)
        {
            string factoryMethodName = "SyntaxFactory.Trivia";
            string text = syntaxTrivia.ToString();
            if (syntaxTrivia.FullSpan.Length == 0 ||
                (syntaxTrivia.Kind() == SyntaxKind.WhitespaceTrivia && UseDefaultFormatting))
            {
                return null;
            }

            PropertyInfo triviaFactoryProperty = null;
            if (triviaFactoryProperties.TryGetValue(syntaxTrivia.ToString(), out triviaFactoryProperty) &&
                ((SyntaxTrivia)triviaFactoryProperty.GetValue(null)).Kind() == syntaxTrivia.Kind())
            {
                if (UseDefaultFormatting)
                {
                    return null;
                }

                return new ApiCall(null, "SyntaxFactory." + triviaFactoryProperty.Name);
            }

            if (!string.IsNullOrEmpty(text) &&
                string.IsNullOrWhiteSpace(text) &&
                syntaxTrivia.Kind() == SyntaxKind.WhitespaceTrivia)
            {
                if (UseDefaultFormatting)
                {
                    return null;
                }

                factoryMethodName = "SyntaxFactory.Whitespace";
            }

            if (syntaxTrivia.Kind() == SyntaxKind.SingleLineCommentTrivia ||
                syntaxTrivia.Kind() == SyntaxKind.MultiLineCommentTrivia)
            {
                factoryMethodName = "SyntaxFactory.Comment";
            }

            if (syntaxTrivia.Kind() == SyntaxKind.PreprocessingMessageTrivia)
            {
                factoryMethodName = "SyntaxFactory.PreprocessingMessage";
            }

            if (syntaxTrivia.Kind() == SyntaxKind.DisabledTextTrivia)
            {
                factoryMethodName = "SyntaxFactory.DisabledText";
            }

            if (syntaxTrivia.Kind() == SyntaxKind.DocumentationCommentExteriorTrivia)
            {
                factoryMethodName = "SyntaxFactory.DocumentationCommentExterior";
            }

            object argument = "@\"" + Escape(syntaxTrivia.ToString()) + "\"";

            if (syntaxTrivia.HasStructure)
            {
                argument = QuoteNode(syntaxTrivia.GetStructure(), "Structure");
            }

            return new ApiCall(null, factoryMethodName, CreateArgumentList(argument));
        }

        private void AddFactoryMethodArguments(
            MethodInfo factory,
            MethodCall factoryMethodCall,
            List<ApiCall> quotedValues)
        {
            foreach (var factoryMethodParameter in factory.GetParameters())
            {
                var parameterName = factoryMethodParameter.Name;
                var parameterType = factoryMethodParameter.ParameterType;

                ApiCall quotedCodeBlock = FindValue(parameterName, quotedValues);

                // special case to prefer Syntax.IdentifierName("C") to 
                // Syntax.IdentifierName(Syntax.Identifier("C"))
                if (parameterName == "name" && parameterType == typeof(string))
                {
                    quotedCodeBlock = quotedValues.First(a => a.Name == "Identifier");
                    var methodCall = quotedCodeBlock.FactoryMethodCall as MethodCall;
                    if (methodCall != null && methodCall.Name == "SyntaxFactory.Identifier")
                    {
                        if (methodCall.Arguments.Count == 1)
                        {
                            factoryMethodCall.AddArgument(methodCall.Arguments[0]);
                        }
                        else
                        {
                            factoryMethodCall.AddArgument(quotedCodeBlock);
                        }

                        quotedValues.Remove(quotedCodeBlock);
                        continue;
                    }
                }

                // special case to prefer Syntax.ClassDeclarationSyntax(string) instead of 
                // Syntax.ClassDeclarationSyntax(SyntaxToken)
                if (parameterName == "identifier" && parameterType == typeof(string))
                {
                    var methodCall = quotedCodeBlock.FactoryMethodCall as MethodCall;
                    if (methodCall != null &&
                        methodCall.Name == "SyntaxFactory.Identifier" &&
                        methodCall.Arguments.Count == 1)
                    {
                        factoryMethodCall.AddArgument(methodCall.Arguments[0]);
                        quotedValues.Remove(quotedCodeBlock);
                        continue;
                    }
                }

                if (quotedCodeBlock != null)
                {
                    factoryMethodCall.AddArgument(quotedCodeBlock);
                    quotedValues.Remove(quotedCodeBlock);
                }
                else if (!factoryMethodParameter.IsOptional)
                {
                    throw new InvalidOperationException(
                        string.Format(
                            "Couldn't find value for parameter '{0}' of method '{1}'. Go to QuotePropertyValues and add your node type to the exception list.",
                            parameterName,
                            factory));
                }
            }
        }

        /// <summary>
        /// Helper to quickly create a list from one or several items
        /// </summary>
        private static List<object> CreateArgumentList(params object[] args)
        {
            return new List<object>(args);
        }

        /// <summary>
        /// Escapes strings to be included within "" using C# escaping rules
        /// </summary>
        private string Escape(string text, bool escapeVerbatim = true)
        {
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < text.Length; i++)
            {
                string toAppend = text[i].ToString();
                if (text[i] == '"')
                {
                    if (escapeVerbatim)
                    {
                        toAppend = "\"\"";
                    }
                    else
                    {
                        toAppend = "\\\"";
                    }
                }
                else if (text[i] == '\\' && !escapeVerbatim)
                {
                    toAppend = "\\\\";
                }

                sb.Append(toAppend);
            }

            return sb.ToString();
        }

        /// <summary>
        /// Finds a value in a list using case-insensitive search
        /// </summary>
        private ApiCall FindValue(string parameterName, IEnumerable<ApiCall> values)
        {
            return values.FirstOrDefault(
                v => parameterName.Equals(v.Name, StringComparison.OrdinalIgnoreCase));
        }

        /// <summary>
        /// Static methods on Microsoft.CodeAnalysis.CSharp.SyntaxFactory class that construct SyntaxNodes
        /// </summary>
        /// <example>Syntax.ClassDeclaration()</example>
        private static readonly Dictionary<string, List<MethodInfo>> factoryMethods = GetFactoryMethods();

        /// <summary>
        /// Five public properties on Microsoft.CodeAnalysis.CSharp.SyntaxFactory that return trivia: CarriageReturn,
        /// LineFeed, CarriageReturnLineFeed, Space and Tab.
        /// </summary>
        private static readonly Dictionary<string, PropertyInfo> triviaFactoryProperties = GetTriviaFactoryProperties();

        /// <summary>
        /// Gets the five properties on SyntaxFactory that return ready-made trivia: CarriageReturn,
        /// CarriageReturnLineFeed, LineFeed, Space and Tab.
        /// </summary>
        private static Dictionary<string, PropertyInfo> GetTriviaFactoryProperties()
        {
            var result = typeof(SyntaxFactory)
                .GetProperties(BindingFlags.Public | BindingFlags.Static)
                .Where(propertyInfo => propertyInfo.PropertyType == typeof(SyntaxTrivia))
                .Where(propertyInfo => !propertyInfo.Name.Contains("Elastic"))
                .ToDictionary(propertyInfo => ((SyntaxTrivia)propertyInfo.GetValue(null)).ToString());

            return result;
        }

        /// <summary>
        /// Returns static methods on Roslyn.Compilers.CSharp.Syntax that return types derived from
        /// SyntaxNode and bucketizes them by overloads.
        /// </summary>
        private static Dictionary<string, List<MethodInfo>> GetFactoryMethods()
        {
            var result = new Dictionary<string, List<MethodInfo>>();

            var staticMethods = typeof(SyntaxFactory).GetMethods(
                BindingFlags.Public | BindingFlags.Static);

            foreach (var method in staticMethods)
            {
                var returnTypeName = method.ReturnType.Name;

                List<MethodInfo> bucket = null;
                if (!result.TryGetValue(returnTypeName, out bucket))
                {
                    bucket = new List<MethodInfo>();
                    result.Add(returnTypeName, bucket);
                }

                bucket.Add(method);
            }

            return result;
        }

        /// <summary>
        /// Uses Reflection to inspect static factory methods on the Roslyn.Compilers.CSharp.Syntax
        /// class and pick an overload that creates a node of the same type as the input <paramref
        /// name="node"/>
        /// </summary>
        private MethodInfo PickFactoryMethodToCreateNode(SyntaxNode node)
        {
            string name = node.GetType().Name;

            List<MethodInfo> candidates = null;
            if (!factoryMethods.TryGetValue(name, out candidates))
            {
                throw new NotSupportedException(name + " is not supported");
            }

            int minParameterCount = candidates.Min(m => m.GetParameters().Length);

            // HACK: for LiteralExpression pick the overload with two parameters - the overload with one
            // parameter only allows true/false/null literals
            if (node is LiteralExpressionSyntax)
            {
                SyntaxKind kind = ((LiteralExpressionSyntax)node).Kind();
                if (kind != SyntaxKind.TrueLiteralExpression &&
                    kind != SyntaxKind.FalseLiteralExpression &&
                    kind != SyntaxKind.NullLiteralExpression)
                {
                    minParameterCount = 2;
                }
            }

            MethodInfo factory = null;

            if ((node is BaseTypeDeclarationSyntax ||
                 node is IdentifierNameSyntax))
            {
                Type desiredParameterType = typeof(string);
                factory = candidates.FirstOrDefault(m => m.GetParameters()[0].ParameterType == desiredParameterType);
                if (factory != null)
                {
                    return factory;
                }
            }

            factory = candidates.First(m => m.GetParameters().Length == minParameterCount);
            return factory;
        }

        /// <summary>
        /// Adds information about subsequent modifying fluent interface style calls on an object (like
        /// foo.With(...).With(...))
        /// </summary>
        private void AddModifyingCalls(object treeElement, ApiCall apiCall, List<ApiCall> values)
        {
            var methods = treeElement.GetType().GetMethods(BindingFlags.Public | BindingFlags.Instance);

            foreach (var value in values)
            {
                var properCase = ProperCase(value.Name);
                var methodName = "With" + properCase;
                if (methods.Any(m => m.Name == methodName))
                {
                    methodName = "." + methodName;
                }
                else
                {
                    throw new NotSupportedException();
                }

                var methodCall = new MethodCall
                {
                    Name = methodName,
                    Arguments = CreateArgumentList(value)
                };

                AddModifyingCall(apiCall, methodCall);
            }
        }

        private void AddModifyingCall(ApiCall apiCall, MethodCall methodCall)
        {
            // TODO: this needs scripting
            ////if (RemoveRedundantModifyingCalls)
            ////{
            ////    var before = Evaluate(apiCall, UseDefaultFormatting);
            ////    apiCall.Add(methodCall);
            ////    var after = Evaluate(apiCall, UseDefaultFormatting);
            ////    if (before == after)
            ////    {
            ////        apiCall.Remove(methodCall);
            ////    }
            ////}

            apiCall.Add(methodCall);
            return;
        }

        /// <summary>
        /// Flattens a tree of ApiCalls into a single string.
        /// </summary>
        private string Print(ApiCall root)
        {
            var sb = new StringBuilder();
            Print(root, sb, 0, OpenParenthesisOnNewLine, ClosingParenthesisOnNewLine);
            var generatedCode = sb.ToString();
            return generatedCode;
        }

        private static string PrintWithDefaultFormatting(ApiCall root)
        {
            var sb = new StringBuilder();
            Print(
                root,
                sb,
                0,
                openParenthesisOnNewLine: false,
                closingParenthesisOnNewLine: false);
            var generatedCode = sb.ToString();
            return generatedCode;
        }

        private static void Print(
            ApiCall codeBlock,
            StringBuilder sb,
            int depth = 0,
            bool openParenthesisOnNewLine = false,
            bool closingParenthesisOnNewLine = false)
        {
            Print(
                codeBlock.FactoryMethodCall,
                sb,
                depth,
                useCurliesInsteadOfParentheses: codeBlock.UseCurliesInsteadOfParentheses,
                openParenthesisOnNewLine: openParenthesisOnNewLine,
                closingParenthesisOnNewLine: closingParenthesisOnNewLine);
            if (codeBlock.InstanceMethodCalls != null)
            {
                foreach (var call in codeBlock.InstanceMethodCalls)
                {
                    PrintNewLine(sb);
                    Print(
                        call,
                        sb,
                        depth,
                        useCurliesInsteadOfParentheses: codeBlock.UseCurliesInsteadOfParentheses,
                        openParenthesisOnNewLine: openParenthesisOnNewLine,
                        closingParenthesisOnNewLine: closingParenthesisOnNewLine);
                }
            }
        }

        private static void Print(
            MemberCall call,
            StringBuilder sb,
            int depth,
            bool openParenthesisOnNewLine = false,
            bool closingParenthesisOnNewLine = false,
            bool useCurliesInsteadOfParentheses = false)
        {
            var openParen = useCurliesInsteadOfParentheses ? "{" : "(";
            var closeParen = useCurliesInsteadOfParentheses ? "}" : ")";
            Print(call.Name, sb, depth);

            MethodCall methodCall = call as MethodCall;
            if (methodCall != null)
            {
                if (methodCall.Arguments == null || !methodCall.Arguments.Any())
                {
                    Print(openParen + closeParen, sb, 0);
                    return;
                }

                if (openParenthesisOnNewLine)
                {
                    PrintNewLine(sb);
                    Print(openParen, sb, depth);
                }
                else
                {
                    Print(openParen, sb, 0);
                }

                PrintNewLine(sb);

                bool needComma = false;
                foreach (var block in methodCall.Arguments)
                {
                    if (needComma)
                    {
                        Print(",", sb, 0);
                        PrintNewLine(sb);
                    }

                    if (block is string)
                    {
                        Print(
                            (string)block,
                            sb,
                            depth + 1);
                    }
                    else if (block is SyntaxKind)
                    {
                        Print("SyntaxKind." + ((SyntaxKind)block).ToString(), sb, depth + 1);
                    }
                    else if (block is ApiCall)
                    {
                        Print(
                            block as ApiCall,
                            sb,
                            depth + 1,
                            openParenthesisOnNewLine: openParenthesisOnNewLine,
                            closingParenthesisOnNewLine: closingParenthesisOnNewLine);
                    }

                    needComma = true;
                }

                if (closingParenthesisOnNewLine)
                {
                    PrintNewLine(sb);
                    Print(closeParen, sb, depth);
                }
                else
                {
                    Print(closeParen, sb, 0);
                }
            }
        }

        private static void PrintNewLine(StringBuilder sb)
        {
            sb.AppendLine();
        }

        private static void Print(string line, StringBuilder sb, int indent)
        {
            PrintIndent(sb, indent);
            sb.Append(line);
        }

        private static void PrintIndent(StringBuilder sb, int indent)
        {
            sb.Append(new string(' ', indent * 4));
        }

        private static string ProperCase(string str)
        {
            return char.ToUpperInvariant(str[0]) + str.Substring(1);
        }

        /// <summary>
        /// Enumerates names of properties on SyntaxNode, SyntaxToken and SyntaxTrivia classes that do
        /// not impact the shape of the syntax tree and are not essential to reconstructing the tree.
        /// </summary>
        private static readonly string[] nonStructuralProperties =
        {
        "AllowsAnyExpression",
        "Arity",
        "ContainsAnnotations",
        "ContainsDiagnostics",
        "ContainsDirectives",
        "ContainsSkippedText",
        "DirectiveNameToken",
        "FullSpan",
        "HasLeadingTrivia",
        "HasTrailingTrivia",
        "HasStructuredTrivia",
        "HasStructure",
        "IsConst",
        "IsDirective",
        "IsElastic",
        "IsFixed",
        "IsMissing",
        "IsStructuredTrivia",
        "IsUnboundGenericName",
        "IsVar",
        "Kind",
        "Language",
        "Parent",
        "ParentTrivia",
        "PlainName",
        "Span",
        "SyntaxTree",
    };

        /// <summary>
        /// "Stringly typed" representation of a C# property or method invocation expression, with a
        /// string for the property or method name and a list of similarly loosely typed argument
        /// expressions. Simply speaking, this is a tree of strings.
        /// </summary>
        /// <example>
        /// Data structure to represent code (API calls) of simple hierarchical shape such as:
        /// A.B(C, D.E(F(G, H), I))
        /// </example>
        private class ApiCall
        {
            public string Name { get; private set; }
            public MemberCall FactoryMethodCall { get; private set; }
            public List<MethodCall> InstanceMethodCalls { get; private set; }
            public bool UseCurliesInsteadOfParentheses { get; private set; }

            public ApiCall()
            {
            }

            public ApiCall(string parentPropertyName, string factoryMethodName)
            {
                Name = parentPropertyName;
                FactoryMethodCall = new MemberCall
                {
                    Name = factoryMethodName
                };
            }

            public ApiCall(string parentPropertyName, string factoryMethodName, List<object> arguments, bool useCurliesInsteadOfParentheses = false)
            {
                UseCurliesInsteadOfParentheses = useCurliesInsteadOfParentheses;
                Name = parentPropertyName;
                FactoryMethodCall = new MethodCall
                {
                    Name = factoryMethodName,
                    Arguments = arguments
                };
            }

            public ApiCall(string name, MethodCall factoryMethodCall)
            {
                Name = name;
                FactoryMethodCall = factoryMethodCall;
            }

            public void Add(MethodCall methodCall)
            {
                if (InstanceMethodCalls == null)
                {
                    InstanceMethodCalls = new List<MethodCall>();
                }

                InstanceMethodCalls.Add(methodCall);
            }

            public void Remove(MethodCall methodCall)
            {
                if (InstanceMethodCalls == null)
                {
                    return;
                }

                InstanceMethodCalls.Remove(methodCall);
            }

            public override string ToString()
            {
                return Quoter.PrintWithDefaultFormatting(this);
            }
        }

        /// <summary>
        /// Simple data structure to represent a member call, primarily just the string Name.
        /// </summary>
        private class MemberCall
        {
            public string Name { get; set; }

            public override string ToString()
            {
                var sb = new StringBuilder();
                Quoter.Print(this, sb, 0);
                return sb.ToString();
            }
        }

        /// <summary>
        /// Represents a method call that has a Name and an arbitrary list of Arguments.
        /// </summary>
        private class MethodCall : MemberCall
        {
            public List<object> Arguments { get; set; }

            public void AddArgument(object value)
            {
                if (Arguments == null)
                {
                    Arguments = new List<object>();
                }

                Arguments.Add(value);
            }
        }
    }
}